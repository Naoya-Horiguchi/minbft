// Copyright (c) 2018 NEC Laboratories Europe GmbH.
//
// Authors: Sergey Fedorov <sergey.fedorov@neclab.eu>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sgx

/*
// TODO Use pkg-config?
#cgo CPPFLAGS: -I/opt/intel/sgxsdk/include
#cgo LDFLAGS: -ldl

#include <dlfcn.h>
#include <stdlib.h>

#include <sgx_urts.h>
#include <sgx_tcrypto.h>

// wrappers to call a function through a function pointer, which is returned by
// dlsym().

sgx_status_t usig_init(const void *pointer,
                       const char *enclave_file, sgx_enclave_id_t *enclave_id,
                       void *sealed_data, size_t sealed_data_size)
{
	return ((sgx_status_t (*)(const char *, sgx_enclave_id_t *, void *, size_t)) pointer)
			(enclave_file, enclave_id, sealed_data, sealed_data_size);
}

sgx_status_t usig_destroy(const void *pointer,
                          const sgx_enclave_id_t enclave_id)
{
	return ((sgx_status_t (*)(const sgx_enclave_id_t)) pointer)(enclave_id);
}

sgx_status_t usig_create_ui(const void *pointer,
                            sgx_enclave_id_t enclave_id,
                            sgx_sha256_hash_t digest,
                            uint64_t *counter,
                            sgx_ec256_signature_t *signature)
{
	return ((sgx_status_t (*)(sgx_enclave_id_t, sgx_sha256_hash_t, uint64_t *, sgx_ec256_signature_t *)) pointer)
			(enclave_id, digest, counter, signature);
}

sgx_status_t usig_get_epoch(const void *pointer,
                            sgx_enclave_id_t enclave_id,
                            uint64_t *epoch)
{
	return ((sgx_status_t (*)(sgx_enclave_id_t, uint64_t *)) pointer)
			(enclave_id, epoch);
}

sgx_status_t usig_get_pub_key(const void *pointer,
                              sgx_enclave_id_t enclave_id,
                              sgx_ec256_public_t *pub_key)
{
	return ((sgx_status_t (*)(sgx_enclave_id_t, sgx_ec256_public_t *)) pointer)
			(enclave_id, pub_key);
}

sgx_status_t usig_seal_key(const void *pointer,
                           sgx_enclave_id_t enclave_id,
                           void **sealed_data,
                           size_t *sealed_data_size)
{
	return ((sgx_status_t (*)(sgx_enclave_id_t, void **, size_t *)) pointer)
			(enclave_id, sealed_data, sealed_data_size);
}
*/
import "C"

import (
	"bytes"
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/sha256"
	"encoding/asn1"
	"encoding/binary"
	"errors"
	"fmt"
	"math/big"
	"sync"
	"unsafe"
)

const (
	// TODO To be able to give a path from the CLI/config.
	untrustedFile = "libusig_shim.so"
)

// Digest represents the data type of the message digest used to
// create unique identifiers
type Digest [sha256.Size]byte

// USIGEnclave represents a USIG enclave instance.
type USIGEnclave struct {
	// A handle of the dynamically loaded untrusted library.
	handle unsafe.Pointer
	// USIG enclave is supposed to be single-threaded. This lock
	// is used to synchronize ECall invocations and avoid
	// SGX_ERROR_OUT_OF_TCS error.
	ecallLock sync.Mutex
	enclaveID C.sgx_enclave_id_t
	epoch     uint64
}

// NewUSIGEnclave creates a new instance of USIG enclave. Note that
// the created instance has to be disposed with Destroy() method, e.g.
// using defer. A sealed key, previously retrieved by SealedKey(), can
// be supplied to initialize the enclave with that key pair. If nil is
// passed instead then a new key pair will be generated by the
// enclave.
func NewUSIGEnclave(enclaveFile string, sealedKey []byte) (*USIGEnclave, error) {
	var err error

	enclave := new(USIGEnclave)

	enclave.handle, err = dlopen()
	if err != nil {
		return nil, err
	}

	sealedDataSize := C.size_t(len(sealedKey))
	var sealedData unsafe.Pointer
	if len(sealedKey) != 0 {
		sealedData = C.CBytes(sealedKey)
		defer C.free(sealedData)
	}

	sgxErr := C.usig_init(
		dlsymOrPanic(enclave.handle, "usig_init"),
		C.CString(enclaveFile), &enclave.enclaveID,
		sealedData, sealedDataSize,
	)
	if err := sgxError(sgxErr); err != nil {
		return nil, err
	}

	sgxSuccessOrPanic(C.usig_get_epoch(
		dlsymOrPanic(enclave.handle, "usig_get_epoch"),
		enclave.enclaveID, (*C.uint64_t)(&enclave.epoch)),
	)

	return enclave, nil
}

// Destroy destroys previously created USIG enclave instance. Must be
// called only once per each enclave instance
func (enclave *USIGEnclave) Destroy() {
	function := dlsymOrPanic(enclave.handle, "usig_destroy")

	// USIGEnclave is supposed to be exposed only after it has
	// been created and initialized successfully. Enclave destroy
	// can only fail if the enclave ID is not valid. That would
	// mean double-destroy here. This is deemed a programmer
	// error, similar to double-closing a channel, thus panic().
	enclave.ecallLock.Lock()
	sgxSuccessOrPanic(C.usig_destroy(function, enclave.enclaveID))
	enclave.ecallLock.Unlock()

	if err := dlclose(enclave.handle); err != nil {
		panic(err)
	}
}

// CreateUI assigns the next USIG counter value to the specified
// message digest. The assigned counter value and serialized USIG
// signature are returned.
func (enclave *USIGEnclave) CreateUI(digest Digest) (counter uint64, signature []byte, err error) {
	function := dlsymOrPanic(enclave.handle, "usig_create_ui")
	sgxSignature := new(C.sgx_ec256_signature_t)

	enclave.ecallLock.Lock()
	sgxErr := C.usig_create_ui(function,
		enclave.enclaveID, (*C.uint8_t)(&digest[0]),
		(*C.uint64_t)(&counter), sgxSignature)
	enclave.ecallLock.Unlock()
	if err := sgxError(sgxErr); err != nil {
		return uint64(0), nil, err
	}

	return counter, sgxEC256SigToASN1(sgxSignature), nil
}

// VerifySignature verifies a USIG signature over the message digest,
// epoch and counter values, given a USIG public key.
func VerifySignature(pubKey interface{}, digest Digest, epoch, counter uint64, signature []byte) error {
	ecdsaPubKey, ok := pubKey.(*ecdsa.PublicKey)
	if !ok {
		return fmt.Errorf("invalid USIG ID format: expected ECDSA public key")
	}

	buf := bytes.NewBuffer(digest[:])
	err := binary.Write(buf, binary.LittleEndian, epoch)
	if err != nil {
		panic(err)
	}
	err = binary.Write(buf, binary.LittleEndian, counter)
	if err != nil {
		panic(err)
	}

	hash := sha256.Sum256(buf.Bytes())

	ecdsaSignature := new(struct{ R, S *big.Int })
	rest, err := asn1.Unmarshal(signature, ecdsaSignature)
	if err != nil {
		return fmt.Errorf("failed to unmarshal USIG signature: %v", err)
	} else if len(rest) != 0 {
		return fmt.Errorf("extra bytes in USIG signature")
	}

	if !ecdsa.Verify(ecdsaPubKey, hash[:], ecdsaSignature.R, ecdsaSignature.S) {
		return fmt.Errorf("signature not valid")
	}

	return nil
}

// Epoch retrieves the unique epoch value generated by this USIG
// enclave instance.
func (enclave *USIGEnclave) Epoch() uint64 {
	return enclave.epoch
}

// PublicKey retrieves the public part of the key used by USIG enclave
// instance to sign unique identifiers it produces
func (enclave *USIGEnclave) PublicKey() crypto.PublicKey {
	function := dlsymOrPanic(enclave.handle, "usig_get_pub_key")
	sgxPubKey := new(C.sgx_ec256_public_t)

	enclave.ecallLock.Lock()
	sgxErr := C.usig_get_pub_key(function, enclave.enclaveID, sgxPubKey)
	enclave.ecallLock.Unlock()
	sgxSuccessOrPanic(sgxErr)

	return sgxEC256PubKeyToGo(sgxPubKey)
}

// SealedKey retrieves the sealed key used by the USIG enclave. The
// retrieved key can be supplied to subsequent calls to
// NewUSIGEnclave() on the same physical machine.
func (enclave *USIGEnclave) SealedKey() []byte {
	function := dlsymOrPanic(enclave.handle, "usig_seal_key")
	var sealedData unsafe.Pointer
	var sealedDataSize C.size_t

	enclave.ecallLock.Lock()
	sgxErr := C.usig_seal_key(function, enclave.enclaveID, &sealedData, &sealedDataSize)
	enclave.ecallLock.Unlock()
	sgxSuccessOrPanic(sgxErr)

	bytes := C.GoBytes(sealedData, C.int(sealedDataSize))
	C.free(sealedData)

	return bytes
}

func sgxError(sgxErr C.sgx_status_t) error {
	if sgxErr != C.SGX_SUCCESS {
		return fmt.Errorf("SGX error: %x", sgxErr)
	}

	return nil
}

func sgxSuccessOrPanic(sgxErr C.sgx_status_t) {
	if err := sgxError(sgxErr); err != nil {
		panic(err)
	}
}

func sgxEC256SigToASN1(sgxSig *C.sgx_ec256_signature_t) []byte {
	sgxR, sgxS := sgxSig.x[:], sgxSig.y[:]
	r := sgxUint32SliceToBigInt(sgxR)
	s := sgxUint32SliceToBigInt(sgxS)

	ret, err := asn1.Marshal(struct{ R, S *big.Int }{r, s})
	if err != nil {
		panic(err)
	}

	return ret
}

func sgxEC256PubKeyToGo(sgxPubKey *C.sgx_ec256_public_t) crypto.PublicKey {
	sgxX, sgxY := sgxPubKey.gx[:], sgxPubKey.gy[:]

	return &ecdsa.PublicKey{
		Curve: elliptic.P256(),
		X:     sgxUint8SliceToBigInt(sgxX),
		Y:     sgxUint8SliceToBigInt(sgxY),
	}
}

func sgxUint32SliceToBigInt(sgxArr []C.uint32_t) *big.Int {
	bytes := make([]byte, 0, len(sgxArr)*4)

	// Convert SGX representation encoded as a series of 32-bit
	// integers in little endian order to a big endian byte slice
	for i := len(sgxArr); i > 0; i-- {
		w := sgxArr[i-1]
		bytes = append(bytes,
			byte(w>>(3*8)),
			byte(w>>(2*8)),
			byte(w>>(1*8)),
			byte(w>>(0*8)))
	}

	return new(big.Int).SetBytes(bytes)
}

func sgxUint8SliceToBigInt(sgxArr []C.uint8_t) *big.Int {
	bytes := make([]byte, 0, len(sgxArr))

	// Convert SGX representation encoded as a series of bytes in
	// little endian order to big endian byte slice
	for i := len(sgxArr); i > 0; i-- {
		b := sgxArr[i-1]
		bytes = append(bytes, byte(b))
	}

	return new(big.Int).SetBytes(bytes)
}

func dlopen() (unsafe.Pointer, error) {
	f := C.CString(untrustedFile)
	defer C.free(unsafe.Pointer(f))

	handle := C.dlopen(f, C.RTLD_LAZY)
	if handle == nil {
		return nil, dlerror()
	}

	return handle, nil
}

func dlclose(handle unsafe.Pointer) error {
	e := C.dlclose(handle)
	if e != 0 {
		return dlerror()
	}

	return nil
}

// dlsymOrPanic returns the address where the name of a function is loaded.
// Because a library that includes the functions is a part of this project
// (i.e. it is not a user-developed extension), we assume all the functions are
// implemented and if there is an error then call panic.
func dlsymOrPanic(handle unsafe.Pointer, name string) unsafe.Pointer {
	n := C.CString(name)
	defer C.free(unsafe.Pointer(n))

	pointer := C.dlsym(handle, n)
	if pointer == nil {
		panic(dlerror())
	}

	return pointer
}

func dlerror() error {
	s := C.dlerror()
	if s == nil {
		return nil
	}

	return errors.New(C.GoString(s))
}
